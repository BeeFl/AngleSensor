C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ANGLE
OBJECT MODULE PLACED IN .\Objects\angle.obj
COMPILER INVOKED BY: F:\keil\C51\BIN\C51.EXE angle.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\angle.
                    -lst) TABS(2) OBJECT(.\Objects\angle.obj)

line level    source

   1          #include "STC.h"
   2          #include <intrins.h>
   3          #include  "PWMn.h"
   4          
   5          #define   BUF_LENTH 64    //定义串口1接收缓冲长度
   6          
   7          //通过控制pwm占空比来输出4-20mA的电流
   8          #define   PWM_START 960 //对应4mA电流的初始量（必须准确）
   9          #define   PWM_END 3600 //对应20mA电流的初始量（不必准确）
  10          
  11          #define   DIGITAL_DELAY   15
  12          
  13          #define SSIG    1 //1: 忽略SS脚，由MSTR位决定主机还是从机   0: SS脚用于决定主从机。
  14          #define SPEN    1 //1: 允许SPI，                0：禁止SPI，所有SPI管脚均为普通IO
  15          #define DORD    0 //1：LSB先发，                0：MSB先发
  16          #define MSTR    1 //1：设为主机               0：设为从机
  17          #define CPOL    1 //1: 空闲时SCLK为高电平，         0：空闲时SCLK为低电平
  18          #define CPHA    1 //SPI时钟相位选择 设置为1时，数据在SPICLK的前时钟沿驱动，并在后时钟沿采样
  19          #define SPR1    0 //SPR1,SPR0   00: fosc/4,     01: fosc/16
  20          #define SPR0    0 //            10: fosc/64,    11: fosc/128
  21          #define SPEED_4   0 // fosc/4
  22          #define SPEED_16  1 // fosc/16
  23          #define SPEED_64  2 // fosc/64
  24          #define SPEED_128 3 // fosc/128
  25          
  26          #define SPIF  0x80    //SPI传输完成标志。写入1清0。
  27          #define WCOL  0x40    //SPI写冲突标志。写入1清0。
  28          
  29          /*************** 用户定义参数 *****************************/
  30          
  31          #define MAIN_Fosc   11059200L //定义主时钟，我用的是11.0592MHZ->11059200L
  32          #define Baudrate1   9600L   //定义串口1波特率
  33          #define Baudrate2   9600L   //定义串口2波特率
  34          
  35          /****************** 编译器自动生成，用户请勿修改 ************************************/
  36          
  37          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate1)     //计算12T模式下定时器1重载值
  38          
  39          #define BRT_Reload    (256 - MAIN_Fosc / 12 / 16 / Baudrate2)   //计算12T模式下BRT重载值
  40          
  41          #define TI2       (S2CON & 0x02) != 0//串口2发送中断
  42          #define RI2       (S2CON & 0x01) != 0//串口2接收中断
  43          #define CLR_TI2()   S2CON &= ~0x02//清除串口2发送中断
  44          #define CLR_RI2()   S2CON &= ~0x01//清除串口2接收中断
  45          /**********************************************************/
  46          
  47          unsigned char   idata receive_data;//SPI接收中断中接收从MT6816发送的角度数据
  48          
  49          unsigned char   uart0_wr;   //串口1写指针
  50          unsigned char   uart0_rd;   //串口1读指针
  51          unsigned char   idata RX0_Buffer[BUF_LENTH];//串口接收缓存字符数组
  52          
  53          unsigned char code AscLed[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};//数码管硬编码
  54          
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 2   

  55          bit   B_TI;//串口1中断标志位
  56          bit   B_TI2;//串口2中断标志位
  57          
  58          sbit  SPI_SCL   = P1^7; //SPI卡同步时钟
  59          sbit  SPI_MISO  = P1^6; //SPI卡同步数据
  60          sbit  SPI_MOSI  = P1^5; //SPI卡同步数据
  61          sbit  SPI_CS    = P1^4; //SPI卡片选
  62          
  63          //sbit PWM = P1^3;PWM信号输出的端口
  64          sbit DIR485 = P0^0;//485信号的收发控制引脚
  65          
  66          //sbit LED_RX = P3^0;
  67          //sbit LED_TX = P3^1;
  68          
  69          //sbit LED_RX2 = P4^2;
  70          //sbit LED_TX2 = P4^3;
  71          
  72          //以下是数码管位码引脚
  73          sbit DIG1 = P0^1;
  74          sbit DIG2 = P0^2;
  75          sbit DIG3 = P0^3;
  76          sbit DIG4 = P0^4;
  77          
  78          /*************  本地函数声明  **************/
  79          void  SPI_init(void);//SPI初始化函数
  80          void  uart0_init(void);//串口0初始化函数
  81          void  uart2_init(void);//串口2初始化函数
  82          void  port_init(void);//端口初始化
  83          void  SPI_test(void);//SPI功能测试函数
  84          void  SPI_send(unsigned char c);//通过SPI发送字符到MT6816
  85          void  uart0_send(unsigned char c);//通过串口1发送字符到计算机，调试用
  86          void  uart2_send(unsigned char c);//通过串口2发送字符给485芯片
  87          void  Delay_ms(unsigned int n);//MS延时函数(12M晶振下测试)
  88          void  PWM_test();//PWM功能测试函数
  89          void  Digital_tube_four(float fangle);//数码管显示函数
  90          void  Digital_tube_four_for_error(void);//数码管错误显示函数
  91          void show_for_begin();
  92          
  93          void angle_data_process(void);//处理角度数据
  94          
  95          void tx(unsigned int dat);
  96          void tx2(unsigned int dat);
  97          void PrintString(unsigned char code *puts);
  98          void PrintString2(unsigned char code *puts);
  99          void real_main(void);
 100          /*************  本地变量声明  **************/
 101          unsigned int  pwm;    //定义用户操作的PWM变量
 102          
 103          unsigned int iangle;//以下是关于数码管显示的变量声明
 104          float xiaoshu;
 105          unsigned int bai;
 106          unsigned int shi;
 107          unsigned int ge;
 108          
 109          /****************  外部函数声明和外部变量声明 *****************/
 110          extern unsigned int PWM_high;     //PWM占空比寄存器，即PWM输出高电平的PCA时钟脉冲个数（占空比写入变量）。
 111          void PWMn_SetHighReg(unsigned int high);
 112          void PWMn_init(unsigned int high);
 113          
 114          
 115          bit send;
 116          
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 3   

 117          unsigned int DATA_1;    //
 118          unsigned int DATA_2;    //
 119          unsigned int  DATA_send;
 120          unsigned char state;
 121          float angle;
 122          float angle_tmp;
 123          unsigned int angle_tmp_int;
 124          float angle_tmp_decimal;
 125          //****************************************************
 126          //主函数
 127          //****************************************************
 128          void main()
 129          {
 130   1      
 131   1        real_main();
 132   1      
 133   1        
 134   1      }
 135          
 136          void real_main(void)
 137          {
 138   1        AUXR1 |= (1<<4);  //将UART2从P1口切换到 RXD2--P1.2切换到P4.2   TXD2---P1.3切换到P4.3
 139   1        uart2_init();//串口2初始化
 140   1        DIR485 = 1;//485默认是发状态
 141   1        uart0_init();//串口1初始化
 142   1        SPI_init();//SPI初始化
 143   1        pwm = PWM_HIGH_MIN;
 144   1        PWMn_init(pwm);
 145   1        Delay_ms(1000);
 146   1        uart0_rd = 0;
 147   1        uart0_wr = 0;
 148   1        send=0;
 149   1        state = 0;
 150   1        PrintString2("test for uart2\r\n");
 151   1      
 152   1        while(1)
 153   1        {
 154   2      //    Delay_ms(10);
 155   2      //    if(uart0_rd != uart0_wr)  //串口0转发
 156   2      //    {
 157   2      //      CR = 0;//停止PCA
 158   2            SPI_CS = 0;//SPI片选必须一直置0，不然无数据
 159   2            SPI_send(0x83);//第一次 为无关数 忽略
 160   2        //    PrintString2("test for first\r\n");
 161   2            SPI_send(0x83);//第二次为高8位
 162   2        //    PrintString2("test for second\r\n");
 163   2            DATA_1=receive_data;
 164   2            SPI_send(0x83);//第三次为低8位
 165   2        //    PrintString2("test for third\r\n");
 166   2            DATA_2=receive_data;
 167   2          
 168   2            if((receive_data & 0x02) == 0x02 )//进行磁场强度测试，如果强度不够，打印cannot detect enough magnetic f
             -ield
 169   2            {
 170   3              PrintString2("cannot detect enough magnetic field\r\n");//收到这个且乱码了
 171   3              state = 2;
 172   3            }else{
 173   3              DATA_1=DATA_1<<8;
 174   3              DATA_send=DATA_1|DATA_2;
 175   3              DATA_send=DATA_send>>2;
 176   3              tx2(DATA_send);
 177   3              state = 1;
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 4   

 178   3            }
 179   2            if(state == 1)
 180   2            {
 181   3              angle_data_process();
 182   3            }
 183   2      //      if(++uart0_rd >= BUF_LENTH)   uart0_rd = 0;
 184   2      //    }
 185   2          
 186   2          
 187   2          if(state == 0 || state == 2)
 188   2          {
 189   3            Digital_tube_four_for_error();
 190   3      ////      //进行pwm生成方波
 191   3      //      pwm = PWM_END;
 192   3      //      PWMn_SetHighReg(pwm);
 193   3          }else
 194   2          {
 195   3            Digital_tube_four(angle);
 196   3            //进行pwm生成方波
 197   3            
 198   3            if(angle<=330.0)
 199   3            {
 200   4            
 201   4              pwm = PWM_START + angle*2*4;
 202   4              PWMn_SetHighReg(pwm);
 203   4      //      }else{
 204   4      //        pwm = PWM_END;
 205   4      //        PWMn_SetHighReg(pwm);
 206   4            }
 207   3            
 208   3          }
 209   2            
 210   2        }
 211   1      }
 212          
 213          
 214          /**********************************************/
 215          void  SPI_init(void)  //配置SPI接口
 216          {
 217   1        SPCTL = (SSIG << 7) + (SPEN << 6) + (DORD << 5) + (MSTR << 4) + (CPOL << 3) + (CPHA << 2) + SPEED_64;
 218   1        IE2 |= 0x02;  //允许SPI中断
 219   1      }
 220          
 221          void  port_init(void)
 222          {
 223   1        P0M1 = 0x00;
 224   1        P0M0 = 0x1E;
 225   1      }
 226          
 227          void angle_data_process(void)
 228          {
 229   1        angle = (DATA_send*1.0/16384.0)*360;
 230   1        angle_tmp = angle*10;
 231   1        angle_tmp_int = (unsigned int)angle_tmp;
 232   1        angle_tmp_decimal = angle_tmp - angle_tmp_int;
 233   1        if(angle_tmp_decimal > 0.5)
 234   1        {
 235   2          angle_tmp_int++;//进位
 236   2        }
 237   1        angle_tmp = angle_tmp_int*1.0/10.0;
 238   1        angle_tmp_int = (unsigned int)angle_tmp;
 239   1        angle_tmp_decimal = angle_tmp - angle_tmp_int;
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 5   

 240   1        if(angle_tmp_decimal < 0.75 && angle_tmp_decimal > 0.25)
 241   1        {
 242   2          angle_tmp_decimal = 0.5;
 243   2        }else if(angle_tmp_decimal < 0.25)
 244   1        {
 245   2          angle_tmp_decimal = 0.0;
 246   2        }else if(angle_tmp_decimal > 0.75)
 247   1        {
 248   2          angle_tmp_decimal = 1.0;
 249   2        }
 250   1        angle = angle_tmp_int*1.0 + angle_tmp_decimal;
 251   1      }
 252          
 253          void SPI_send(unsigned char c)
 254          {
 255   1        CR = 0;//关闭PCA
 256   1        SPSTAT = SPIF + WCOL;     //清0 SPIF和WCOL标志
 257   1        SPDAT=c;
 258   1        
 259   1      //  LED_RX2 = 0;//点亮灯，看程序是否运行到这 ->这条代码非常重要，删除就没用了(可能是提供了必要的延时）
 260   1        _nop_();
 261   1        _nop_();
 262   1        _nop_();
 263   1        while((SPSTAT & SPIF) == 0) ; //等待发送完成
 264   1      //  PrintString2("test for first-1\r\n");
 265   1        SPSTAT = SPIF + WCOL;       //清0 SPIF和WCOL标志
 266   1      
 267   1        CR = 1;           //启动PCA。
 268   1        while(send==0);
 269   1      //  PrintString2("test for first-2\r\n");
 270   1        send=0;
 271   1      }
 272          
 273          void show_for_begin()
 274          {
 275   1        port_init();
 276   1      
 277   1        P2 = 0xC0;
 278   1        DIG1 = 1;DIG2 = 0;DIG3 = 0;DIG4 = 0;
 279   1        Delay_ms(DIGITAL_DELAY);
 280   1        
 281   1      
 282   1        P2 = 0xC0;
 283   1        DIG1 = 0;DIG2 = 1;DIG3 = 0;DIG4 = 0;
 284   1        Delay_ms(DIGITAL_DELAY);
 285   1        
 286   1        P2 = 0xC0 & 0x7F;//点亮小数点
 287   1        DIG1 = 0;DIG2 = 0;DIG3 = 1;DIG4 = 0;
 288   1        Delay_ms(DIGITAL_DELAY);
 289   1        
 290   1        P2 = 0xC0;
 291   1        DIG1 = 0;DIG2 = 0;DIG3 = 0;DIG4 = 1;
 292   1        Delay_ms(DIGITAL_DELAY);
 293   1      }
 294          
 295          void Digital_tube_four_for_error(void)
 296          {
 297   1        port_init();
 298   1        P2 = 0xBF;
 299   1        DIG1 = 1;DIG2 = 1;DIG3 = 1;DIG4 = 1;
 300   1      }
 301          
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 6   

 302          void Digital_tube_four(float fangle)//如180.5，已做四舍五入
 303          {
 304   1        port_init();
 305   1        //P2端口连接
 306   1        iangle = (unsigned int)fangle;//180
 307   1        xiaoshu = fangle - iangle;
 308   1        
 309   1        bai = iangle/100;
 310   1        iangle = iangle%100;
 311   1        P2 = AscLed[bai];
 312   1        DIG1 = 1;DIG2 = 0;DIG3 = 0;DIG4 = 0;
 313   1        Delay_ms(DIGITAL_DELAY);
 314   1        
 315   1        shi = iangle/10;
 316   1        iangle = iangle%10;
 317   1        P2 = AscLed[shi];
 318   1        DIG1 = 0;DIG2 = 1;DIG3 = 0;DIG4 = 0;
 319   1        Delay_ms(DIGITAL_DELAY);
 320   1        
 321   1        ge = iangle;
 322   1        P2 = AscLed[ge] & 0x7F;//点亮小数点
 323   1        DIG1 = 0;DIG2 = 0;DIG3 = 1;DIG4 = 0;
 324   1        Delay_ms(DIGITAL_DELAY);
 325   1        
 326   1        if(xiaoshu == 0.5){
 327   2          P2 = AscLed[5];
 328   2        }else{
 329   2          P2 = AscLed[0];
 330   2        }
 331   1        DIG1 = 0;DIG2 = 0;DIG3 = 0;DIG4 = 1;
 332   1      }
 333          
 334          void PWM_test()//PWM功能测试函数
 335          {
 336   1      //阶数：4
 337   1      //起点：949-》4mA
 338   1      //终点：3646-》20.1mA
 339   1      
 340   1      //  pwm = PWM_HIGH_MIN;   //pwm初值
 341   1        pwm = 949;
 342   1        PWMn_init(pwm); //初始化pwm
 343   1        
 344   1        while (1)
 345   1        {
 346   2      //    Delay_ms(6000); //延时
 347   2      //    pwm += 10;
 348   2      //    if(pwm >= 3646) pwm = 3606;
 349   2      ////    PWMn_SetHighReg(pwm);   //更新PWM的占空比
 350   2        }
 351   1      }
 352          
 353          void uart0_send(unsigned char c)
 354          {
 355   1        B_TI = 0;
 356   1        SBUF = c;//通过串口发送
 357   1        while(!B_TI)  ;
 358   1        B_TI = 0;
 359   1      }
 360          
 361          void  uart2_send(unsigned char c)
 362          {
 363   1        B_TI2 = 0;
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 7   

 364   1        S2BUF = c;
 365   1        while(!B_TI2);
 366   1        B_TI2 = 0;
 367   1      }
 368          
 369          void  uart0_init(void)
 370          {
 371   1        PCON |= 0x80;   //UART0 Double Rate Enable
 372   1        SCON = 0x50;    //UART0 set as 10bit , UART0 RX enable sl:8位吧，不是10位
 373   1        TMOD &= ~(1<<6);    //Timer1 Set as Timer, 12T
 374   1        TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
 375   1        TH1 = T1_TimerReload;   //Load the timer
 376   1        TR1  = 1;//start the timer
 377   1        ES  = 1;
 378   1        EA = 1;
 379   1      }
 380          
 381          /**********************************************/
 382          void  uart2_init(void)
 383          {
 384   1        AUXR |=  (1 << 3);    //串口2波特率加倍 S2SMOD
 385   1        S2CON  = (S2CON & 0x3f) | (1<<6); //串口2模式1，8位UART，(2^S2SMOD / 32) * BRT溢出率
 386   1        S2CON |= 1 << 4;    //允许串2接收
 387   1      
 388   1        AUXR |=  1 << 4;  //baudrate use BRT
 389   1        BRT = BRT_Reload;
 390   1      
 391   1        IE2 |=  1;      //允许串口2中断
 392   1      }
 393          
 394          /**********************************************/
 395          void UART0_RCV (void) interrupt 4
 396          {
 397   1        if(RI)
 398   1        {
 399   2          RI = 0;
 400   2          RX0_Buffer[uart0_wr] = SBUF;
 401   2          if(++uart0_wr >= BUF_LENTH) uart0_wr = 0;
 402   2        }
 403   1      
 404   1        if(TI)
 405   1        {
 406   2          TI = 0;
 407   2          B_TI = 1;
 408   2        }
 409   1      }
 410          
 411          /**********************************************/
 412          void UART2_RCV (void) interrupt 8
 413          {
 414   1        if(TI2)
 415   1        {
 416   2          CLR_TI2();
 417   2          B_TI2 = 1;
 418   2        }
 419   1      }
 420          /**********************************************/
 421          void SPI_Transivion (void) interrupt 9
 422          {
 423   1        CR = 1;//打开PCA
 424   1        send=1;
 425   1      //  SPI_CS = 0; 
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 8   

 426   1        receive_data = SPDAT;
 427   1        SPSTAT = SPIF + WCOL; //清0 SPIF和WCOL标志
 428   1      //  uart0_send(SPI_RxBuffer[SPI_RxWr]);中断不能调用函数
 429   1      //  SPI_CS = 1; 
 430   1      //  if(++SPI_RxWr >= SPI_BUF_LENTH)   SPI_RxWr = 0;
 431   1      }
 432          
 433          //========================================================================
 434          // 函数: void  delay_ms(unsigned char ms)
 435          // 描述: 延时函数。
 436          // 参数: ms,要延时的ms数.
 437          // 返回: none.
 438          // 版本: VER1.0
 439          // 日期: 2010-12-15
 440          // 备注: 
 441          //========================================================================
 442          //void  delay_ms(unsigned char ms)
 443          //{
 444          //     unsigned int i;
 445          //   do
 446          //   {
 447          //    i = MAIN_Fosc / 14000L; //1T
 448          //    while(--i)  ;
 449          //     }while(--ms);
 450          //}
 451          
 452          void Delay_ms(unsigned int n)
 453          {
 454   1        unsigned int  i,j;
 455   1        for(i=0;i<n;i++)
 456   1          for(j=0;j<123;j++);
 457   1      }
 458          
 459          void tx(unsigned int dat)
 460          {
 461   1        uart0_send('D');
 462   1        uart0_send('a');
 463   1        uart0_send('t');
 464   1        uart0_send('a');
 465   1        uart0_send('=');
 466   1        uart0_send(dat/10000 + '0');
 467   1        uart0_send(dat%10000/1000 + '0');
 468   1        uart0_send(dat%1000/100 + '0');
 469   1        uart0_send(dat%100/10 + '0');
 470   1        uart0_send(dat%10 + '0');
 471   1        uart0_send(0x0d);
 472   1        uart0_send(0x0a);
 473   1      }
 474          
 475          void tx2(unsigned int dat)
 476          {
 477   1        uart2_send('D');
 478   1        uart2_send('a');
 479   1        uart2_send('t');
 480   1        uart2_send('a');
 481   1        uart2_send('=');
 482   1        uart2_send(dat/10000 + '0');
 483   1        uart2_send(dat%10000/1000 + '0');
 484   1        uart2_send(dat%1000/100 + '0');
 485   1        uart2_send(dat%100/10 + '0');
 486   1        uart2_send(dat%10 + '0');
 487   1        uart2_send(0x0d);
C51 COMPILER V9.60.0.0   ANGLE                                                             05/31/2021 15:55:14 PAGE 9   

 488   1        uart2_send(0x0a);
 489   1      }
 490          
 491          void PrintString(unsigned char code *puts)    //发送一串字符串
 492          {
 493   1          for (; *puts != 0;  puts++)  uart0_send(*puts);   //遇到停止符0结束
 494   1      }
 495          void PrintString2(unsigned char code *puts)   //发送一串字符串
 496          {
 497   1          for (; *puts != 0;  puts++)  uart2_send(*puts);   //遇到停止符0结束
 498   1      }
 499          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1457    ----
   CONSTANT SIZE    =     65    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37       4
   IDATA SIZE       =     65    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
